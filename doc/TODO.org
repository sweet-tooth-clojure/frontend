* ideas
** store config in the app itself?
*** put path defaults in app config
*** create app config init fn
** validation / forms
*** TODO validate form handler against data received 
*** create a validator that introspecs a map spec to produce invalid keys
*** create some default error-fn
*** respects attr state (only checks dirty)
*** does error-fn
*** subscription
**** does form have any errors?
*** change "state" to "submission-state"
*** make attr-path partial + attr and use form event
*** DONE some way to add on-blur to every input
*** what about validating on-change?
**** don't show error messages while typing initially
**** validate on blur / show error messages
**** update error messages while making changes to correct
** Update form components to be more specific
Instead of the ~builder~ creating a ~data~ subscription for the entire
form, create data and error subscriptions for that attribute
** Update method-url to allow overriding
** Not require timbre?
*Change timbre in build.boot? Don't punch users who don't specify
*timbre in their deps
** Split all handlers into functions and register functions
*- have a function that allows you to register all at once with incerceptors for each
** make http a handler, instead of running it directly as an effect dispatch to handler
*- and handler can run it as an effect, but we can specify interceptors
*on handler
** create a generator
** explore making forms attr-centric
*** [form :name] -> {:data x :base y :errors z}
** common input opts
*** how to give fns access to field arg?
*** could make it a function that returns the common input opts
** check that form-id is actually getting used
** clear system for composing input opts?
*** configure the on-x handlers with a selection of fields to meta-merge
*** finalize the on-x handlers by creating a function that calls doseq on them
** indicate that a field has been positively validated
** better system for avoiding dupe api requests / combining api requests
** the ui/nav connection
*** registering ui keys as dependent on nav
*** what changes indicate that the ui key is no longer relevant?
*** component-did-unmount to clean up after itself
*** not just UI but form as well
** allow :label to take a fn with buffer val as arg
* todo
** DONE Make form-paths base agnostic
Make the ~form-path~ base configurable. Whenever form-path is
referenced, exclude base. Have ~full-form-path~ when base is included?
** DONE finish shadow conversion
*** resolve build.boot / deps.edn duplication
**** figure out how to use deps.edn with boot
**** "scope" bootlaces, boot-test
*** ensure I can still build and deploy a jar
** DONE explore using reitit instead of bide
** DONE don't force match-route to take router
take routes instead... what was the rationale for passing in a router?
** DONE navigation
*** DONE gain firm understanding of how history API works
** DONE define initializer handler
*** should store system somewhere
*** provide system as a coeffect
*** update sync to use system coeffect
** DONE navigation
*** steps
**** DONE parity with accountant
***** add history as a resource to load - coeffect
***** create effect handler that updates history
**** DONE create new handlers that will check :should-change?
**** DONE use core-async to convey route info from update-token to dispatch?
**** DONE try doing an alert for can-exit?
**** DONE update route utils to use new
**** DONE decide on namespace name
**** DONE update to halt! the handler
**** DONE add window.beforeunload handler
*** units
**** named route
**** params
**** hierarchical?
named route encompasses params
can even call out specific params
or: watch for change on any part of route
*** TODO define lifecycle
**** will-change-route
**** will-change-params
**** exit
**** will-enter
**** enter
*** accountant integration
**** copy the prevent-reload-on-known-path code
**** unset the navigate listener key
**** set it to my listener
**** new listener dispatches NAV-CLICK
***** NAV-CLICK handles should-exit
***** results in:
****** (.history setToken) (effect handler)
****** indicate skipping should-exit
**** other events dispatch NAV
** DONE examine route dispatching
*** display alerts for certain transitions
- integrate accountant into re-frame? make pushstate an effect?
*** potential for caching
*** how to manage state teardown
*** introduce the concept of route enter/exit/update
*** instead of making it route-centric, make it navigation-centric
**** replace accountant
**** allow some way to define:
***** additional effects or handlers to trigger on route change
****** loading data
****** sending metrics
***** guards that can prevent route changes
***** flow:
- user clicks link or a :nav event is triggered somehow
- :nav event interceptor checks for :pre definitions
- :pre definitions can be effectful and can prevent :nav effect
- :nav effect is to: call setToken, clean up exits, perform entrances
** DONE distinguish exit/change from unload
** DONE clearer change scope
*** only handle params when it's just a param change
*** don't fire every lifecycle handler
** TODO demo a list
*** edit multiple in place
*** delete
** TODO route lifecycle hierarchy
*** register changes to fire on ANY change
** TODO route-specific forms?
*** auto clean up on route change?
** TODO better route story
*** it should be obvious if you're using a nonexistent route
*** it should be possible to closely tie routes to nav lifecycles
*** route prefixing should be part of ST
*** TODO update forms + routing can be annoying
if i'm updating a user, I have to include code like this:

(stfc/on-submit form-path {:clear  [:buffer :ui-state]
                           :data   {:db/id (last form-path)}
                           :expire {:state 3000}})

I shouldn't have to include :db/id in the data
** TODO add route-specific UI
** TODO consider finer-grained route lifecycle
- can go from route a to route b? (insufficient privileges)
** TODO investigate keyword inheritance to specify a sync adapter
the end result is to have a sync-dispatch function in the config,
which is then accessible in the db

** TODO make sync requests easy to debug
** TODO generic db updating handling special keys
*** vector of maps
*** keys
**** :entity
**** TODO :page should get folded in
**** user should be able to specify own keys
**** store db updaters / key handlers in the app db?
** TODO accountant / routing not handling different query strings
** DELETE lifecycle
*** update to indicate deleting
*** update with response
** TODO document sweet-tooth.frontend.core
** TODO config
*** does it make sense to use duct for config?
** TODO make routed entity a sub
[[file:~/projects/web/sweet-tooth/frontend/src/sweet_tooth/frontend/routes/utils.cljc::(defn%20routed-entity][routed entity code]]
** DONE routed entity parseInt is a code smell, should only have to call once
subscribers should not have to know how to parse routed vars
[[file:~/projects/web/grateful-place-3/src/frontend/grateful_place/subs.cljs::(let%20%5B%5D)%20(stru/routed-entity%20db%20:topic%20:topic-id%20js/parseInt)))][gp3 routed entity]]
